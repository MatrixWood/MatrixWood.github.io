<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Noel Welsh: Learn Shapeless, Find $500</title>
        <link rel="stylesheet" href="../css/bootstrap.min.css" />
        <link rel="stylesheet" href="../css/noelwelsh.css" />
        <link rel="stylesheet" href="../css/tango.css" />
        <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet">
    </head>
    <body>
        <header class="page-header">
            <nav class="nav justify-content-center">
                <strong><a class="nav-link active" href="../">Home</a></strong>
                <a class="nav-link" href="../writing.html">Writing</a>
                <a class="nav-link" href="../projects.html">Projects</a>
                <a class="nav-link" href="../about.html">About</a>
            </nav>
        </header>
        <div class="container">
            <div class="row justify-content-center">
                <div class="col col-9">
                    <main role="main">
                        <article>
    <section class="header">
        <h1>Learn Shapeless, Find $500</h1>
        
            <p><small>October  2, 2014</small></p>
        
    </section>
    <section>
        <p>I spent a few hours learning <a href="https://github.com/milessabin/shapeless">Shapeless</a> and it made me $500.</p>
<p>At ScalaDays 2014, <a href="http://www.originate.com/">Originate</a> ran a <a href="http://www.originate.com/stories/scala-days-2014">competition</a> to implement a simple stack-oriented (aka concatenative) language. The competition hit all three points on my “interesting competition” scoring metric:</p>
<ul>
<li>the subject matter is intrinsically interesting to me;</li>
<li>I thought I could implement a basic solution quite quickly; and</li>
<li>there were clear avenues to expand the solution if I found time.</li>
</ul>
<p>A bit of background. A <a href="http://en.wikipedia.org/wiki/Stack-oriented_programming_language">stack-oriented language</a>, as I understand them, operates by passing parameters on a stack. If you want to add two numbers you push them onto the stack, and them push on the <code>add</code> operation – which in turn pops off the two numbers, adds them, and pushes the result back onto the stack. It’s a very simple model, which has made it popular for some embedded systems, though I have my doubts about how it scales with program size.</p>
<p>The core of the competition is to implement a statically typed concatenative language, which boils down to implementing a heterogenously typed stack. A normal <code>List</code> won’t do, because if we store, say, an <code>Int</code> and <code>String</code> in such a list we’ll end up with a <code>List[Any]</code>. What we want is to the store the type of each element separately. This abstraction is called an <code>HList</code> and is one of the core features of <a href="https://github.com/milessabin/shapeless">Shapeless</a>. I was fairly sure I could use Shapeless to get my basic implementation done, and I was right.</p>
<p>Some of the code was quite straightforward using Shapeless. For example, pushing an element onto the stack is just <code>a :: stack</code> as you’d expect. However I had some difficulty typing binary operations. For these I needed to ensure the stack had at least two elements, and those elements had the expected type. To do this I needed to dig a bit deeper into how Shapeless is implemented.</p>
<p>The key insight is that Shapeless uses implicits to provide evidence that the <code>HList</code> has the type we’re interested in. It supplies a number of implicits for common operations, but as far as I can tell no implementation extracting the first two elements of a list. In a few hours, and after some quality time with the Shapeless source code, I managed to implement my own <code>IsBinary</code> evidence. The actual construction is rather involved, with a healthy amount of indirection and even a method dependent type. But hey, that’s how we roll. To be honest I was just copying the patterns from the Shapeless code.</p>
<p>Rather than trying to explain the code it’s simpler if I just <a href="https://github.com/noelwelsh/concatenative-lang">link to it</a> and you can digest at your leisure. The entire code base is only 112 lines.</p>
<p>All up this was a fun contest. I was very happy (and surprised!) to win the second place entry, though really it is all credit to Shapeless.</p>
    </section>
</article>

                    </main>
                </div>
            </div>
        </div>

        <footer class="text-center">
            <small>
                Site generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </small>
        </footer>
    </body>
</html>
