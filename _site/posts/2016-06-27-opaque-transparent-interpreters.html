<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Noel Welsh: Opaque and Transparent Interpreters</title>
        <link rel="stylesheet" href="../css/bootstrap.min.css" />
        <link rel="stylesheet" href="../css/noelwelsh.css" />
        <link rel="stylesheet" href="../css/tango.css" />
        <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet">
    </head>
    <body>
        <header class="page-header">
            <nav class="nav justify-content-center">
                <strong><a class="nav-link active" href="../">Home</a></strong>
                <a class="nav-link" href="../writing.html">Writing</a>
                <a class="nav-link" href="../projects.html">Projects</a>
                <a class="nav-link" href="../about.html">About</a>
            </nav>
        </header>
        <div class="container">
            <div class="row justify-content-center">
                <div class="col col-9">
                    <main role="main">
                        <article>
    <section class="header">
        <h1>Opaque and Transparent Interpreters</h1>
        
            <p><small>June 27, 2016</small></p>
        
    </section>
    <section>
        <p>The interpreter is the über pattern of functional programming. Most large programs written in a functional style can be viewed as using this pattern. Amongst many reasons, interpreters allow us to handle effects and still keep desirable properties such as substitution.</p>
<p>Given the importance of interpreters it is not surprising there are many implementation strategies. In this blog post I want to discuss one of the main axes along which implementation strategies vary, which is how far we take reification of actions within the interpreter.</p>
<!--more-->
<p>But first, a quick recap of the interpreter pattern, and the secret cheat code of functional programming, reification.</p>
<h2 id="whats-an-interpreter">What’s An Interpreter?</h2>
<p>Our basic definition of an interpreter is anything that separates describing the computation from running it. That’s quite a mouthful, so let’s see a quick example. In <a href="https://github.com/underscoreio/doodle">Doodle</a>, a library for vector graphics we are developing, we can describe a picture like so</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">val</span> picture1 = Image.<span class="fu">circle</span>(<span class="dv">100</span>)</a></code></pre></div>
<p>When we’re describing a picture we can easily compose a new picture from existing pictures.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">val</span> picture2 = picture1 beside picture1</a></code></pre></div>
<p>If we want to draw a picture, we call the <code>draw</code> method. Nothing appears on the screen until we call <code>draw</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1">picture2.<span class="fu">draw</span></a></code></pre></div>
<p>The result of <code>draw</code> is <code>Unit</code>, so we cannot use this result to construct more pictures.</p>
<p>This illustrates the essential features of the interpreter pattern: describing a picture is the “describing the computation” part, and calling <code>draw</code> is the “running the computation” part.</p>
<h2 id="why-do-we-use-interpreters">Why Do We Use Interpreters?</h2>
<p>One important reason for functional programmers liking the interpreter pattern is how it allows us to deal with effects. Effects are problematic, because they break <a href="%7B%%20post_url%202015-06-25-keeping-scala-simple%20%%7D">substitution</a>. Substitution allows easy reasoning about code, so functional programmers strive hard to maintain it. At some point you have to have effects—if not, the programm will not do anything useful. The secret to allowing effects is to delay them until some point in the program where we don’t care about substitution anymore. For example, in a web service we can delay effects till we’ve constructed the program to create the response, and then run that program, causing our database effects and so on to occur. In Doodle we delay effects—drawing—until we’ve fully described the picture we want to draw. If you’re familiar with computer graphics, Doodle is essentially constructing a <a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>.</p>
<h2 id="reification">Reification</h2>
<p><a href="%7B%%20post_url%202015-10-14-reification%20%%7D">Reification</a> is an integral part of the interpreter pattern. Reification means to make the abstract concrete. In the context of interpreters this means to turn an action into data. For example, in the context of Doodle when we call <code>Image.circle(100)</code> this turns into a <code>case class</code> rather than drawing something on the screen. Reification is an essential part of the interpreter pattern as we need to delay running the program for the pattern to work, as described above, and the only way to do this is to create a data structure of some kind.</p>
<h2 id="opaque-and-transparent-interpreters">Opaque and Transparent Interpreters</h2>
<p>With the background out of the way, let’s move to the main content of this post: talking about different implementation strategies. I’m going to use as an example of the <code>Random</code> monad. The <code>Random</code> monad allows us to separate describing how to generate random data from actually introducing randomness. Randomness is an effect (a function that generates a random value breaks substitution, as it returns a different value each time it is called) and so we can use the <code>Random</code> monad to control this effect. The <code>Random</code> monad is very simple to implement and make a good case study of different implementation techniques.</p>
<p>Let’s look at two different implementation strategies. For bonus points I’ve implemented a <a href="http://typelevel.org/cats">cats</a> monad instance for both, but this has no bearing on the point I’m making.</p>
<p>The first strategy is to reify the methods to an algebraic data type.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> cats.<span class="fu">Monad</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">sealed</span> <span class="kw">trait</span> AlgebraicDataType[A] <span class="kw">extends</span> Product <span class="kw">with</span> Serializable {</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span> = scala.<span class="fu">util</span>.<span class="fu">Random</span>): A =</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">this</span> <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">      <span class="kw">case</span> <span class="fu">Primitive</span>(sample) =&gt; <span class="fu">sample</span>(rng)</a>
<a class="sourceLine" id="cb4-7" title="7">      <span class="kw">case</span> <span class="fu">FlatMap</span>(fa, f) =&gt; <span class="fu">f</span>(fa.<span class="fu">run</span>(rng)).<span class="fu">run</span>(rng)</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="kw">def</span> flatMap[B](f: A =&gt; AlgebraicDataType[B]): AlgebraicDataType[B] =</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="fu">FlatMap</span>(<span class="kw">this</span>, f)</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">  <span class="kw">def</span> map[B](f: A =&gt; B): AlgebraicDataType[B] =</a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="fu">FlatMap</span>(<span class="kw">this</span>, (a: A) =&gt; AlgebraicDataType.<span class="fu">always</span>(<span class="fu">f</span>(a)))</a>
<a class="sourceLine" id="cb4-15" title="15">}</a>
<a class="sourceLine" id="cb4-16" title="16"><span class="kw">object</span> AlgebraicDataType {</a>
<a class="sourceLine" id="cb4-17" title="17">  <span class="kw">def</span> always[A](a: A): AlgebraicDataType[A] =</a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="fu">Primitive</span>(rng =&gt; a)</a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20">  <span class="kw">def</span> <span class="dt">int</span>: AlgebraicDataType[Int] =</a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="fu">Primitive</span>(rng =&gt; rng.<span class="fu">nextInt</span>())</a>
<a class="sourceLine" id="cb4-22" title="22"></a>
<a class="sourceLine" id="cb4-23" title="23">  <span class="kw">def</span> <span class="dt">double</span>: AlgebraicDataType[Double] =</a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="fu">Primitive</span>(rng =&gt; rng.<span class="fu">nextDouble</span>())</a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26">  <span class="kw">implicit</span> <span class="kw">object</span> randomInstance <span class="kw">extends</span> Monad[AlgebraicDataType] {</a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="kw">def</span> flatMap[A, B](fa: AlgebraicDataType[A])(f: (A) ⇒ AlgebraicDataType[B]): AlgebraicDataType[B] =</a>
<a class="sourceLine" id="cb4-28" title="28">      fa.<span class="fu">flatMap</span>(f)</a>
<a class="sourceLine" id="cb4-29" title="29"></a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="kw">def</span> pure[A](x: A): AlgebraicDataType[A] =</a>
<a class="sourceLine" id="cb4-31" title="31">      AlgebraicDataType.<span class="fu">always</span>(x)</a>
<a class="sourceLine" id="cb4-32" title="32">  }</a>
<a class="sourceLine" id="cb4-33" title="33">}</a>
<a class="sourceLine" id="cb4-34" title="34"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> FlatMap[A,B](fa: AlgebraicDataType[A], f: A =&gt; AlgebraicDataType[B]) <span class="kw">extends</span> AlgebraicDataType[B]</a>
<a class="sourceLine" id="cb4-35" title="35"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Primitive[A](sample: scala.<span class="fu">util</span>.<span class="fu">Random</span> =&gt; A) <span class="kw">extends</span> AlgebraicDataType[A]</a></code></pre></div>
<p>An alternative implementation strategy is to reify with functions.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> cats.<span class="fu">Monad</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Lambda[A](get: scala.<span class="fu">util</span>.<span class="fu">Random</span> =&gt; A) {</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span> = scala.<span class="fu">util</span>.<span class="fu">Random</span>): A =</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="fu">get</span>(rng)</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="kw">def</span> flatMap[B](f: A =&gt; Lambda[B]): Lambda[B] =</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="fu">Lambda</span>((rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>) =&gt; <span class="fu">f</span>(<span class="fu">get</span>(rng)).<span class="fu">run</span>(rng))</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="kw">def</span> map[B](f: A =&gt; B): Lambda[B] =</a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="fu">Lambda</span>((rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>) =&gt; <span class="fu">f</span>(<span class="fu">get</span>(rng)))</a>
<a class="sourceLine" id="cb5-12" title="12">}</a>
<a class="sourceLine" id="cb5-13" title="13"><span class="kw">object</span> Lambda {</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="kw">def</span> always[A](a: A): Lambda[A] =</a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="fu">Lambda</span>(rng =&gt; a)</a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17">  <span class="kw">def</span> <span class="dt">int</span>: Lambda[Int] =</a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="fu">Lambda</span>(rng =&gt; rng.<span class="fu">nextInt</span>())</a>
<a class="sourceLine" id="cb5-19" title="19"></a>
<a class="sourceLine" id="cb5-20" title="20">  <span class="kw">def</span> <span class="dt">double</span>: Lambda[Double] =</a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="fu">Lambda</span>(rng =&gt; rng.<span class="fu">nextDouble</span>())</a>
<a class="sourceLine" id="cb5-22" title="22"></a>
<a class="sourceLine" id="cb5-23" title="23">  <span class="kw">implicit</span> <span class="kw">object</span> randomInstance <span class="kw">extends</span> Monad[Lambda] {</a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="kw">def</span> flatMap[A, B](fa: Lambda[A])(f: (A) ⇒ Lambda[B]): Lambda[B] =</a>
<a class="sourceLine" id="cb5-25" title="25">      fa.<span class="fu">flatMap</span>(f)</a>
<a class="sourceLine" id="cb5-26" title="26"></a>
<a class="sourceLine" id="cb5-27" title="27">    <span class="kw">def</span> pure[A](x: A): Lambda[A] =</a>
<a class="sourceLine" id="cb5-28" title="28">      Lambda.<span class="fu">always</span>(x)</a>
<a class="sourceLine" id="cb5-29" title="29">  }</a>
<a class="sourceLine" id="cb5-30" title="30">}</a></code></pre></div>
<p>I call the former strategy (<code>AlgebraicDataType</code>) a <em>transparent interpreter</em>, because we can programmatically inspect the <code>AlgebraicDataType</code> data structure, and the later strategy (<code>Lambda</code>) an <em>opaque interpreter</em>, because we can’t look into the anonymous functions. <em>Update: in the literature you’ll find the terms shallow and deep embedding are used for what I call opaque and transparent respectively. Thanks for Gabriel Claramunt for pointing this out.</em></p>
<p>There are two ways in which the opaque interpreter is superior to the transparent interpreter.</p>
<p>The opaque interpreter doesn’t require we implement an algebraic data type to represent the “language” we want to interpret. This certainly saves on the typing. In some sense functions are universal interpreters. We can represent any language we like in terms of functions, so long as we can accept the semantics we get from Scala.</p>
<p>The other main advantage of the opaque interpreter is that code within a function is just code. The compiler is going to have a much easier time optimising the opaque representation than the transparent one. We can say the opaque representation is more transparent to the compiler.</p>
<p>The transparent interpreter is more modular than the opaque one. With a transparent interpreter we can see the structure of the program we’re interpreting in terms of its algebraic data type representation. This means we can choose to interpret it in different ways. For instance, we could print logging information during interpretation, or run in a distributed environment, or use a “stackless” implementation to avoid overflowing the stack in deeply nested calls. With the opaque representation we can’t make these choices.</p>
<p>In summary, transparent interpreters trade performance for flexibility. I usually find that flexibility is the right choice.</p>
<p>It’s worth noting there is another implementation technique (there is always another way in Scala.) This is to use anonymous classes, as show belown in <code>AnonymousTrait</code>. This is still an opaque implementation, just one that is much more verbose than <code>Lambda</code> above.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">import</span> cats.<span class="fu">Monad</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">sealed</span> <span class="kw">trait</span> AnonymousTrait[A] { self =&gt;</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span> = scala.<span class="fu">util</span>.<span class="fu">Random</span>): A</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="kw">def</span> flatMap[B](f: A =&gt; AnonymousTrait[B]): AnonymousTrait[B] =</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">new</span> AnonymousTrait[B] {</a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>): B =</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="fu">f</span>(self.<span class="fu">run</span>(rng)).<span class="fu">run</span>(rng)</a>
<a class="sourceLine" id="cb6-10" title="10">    }</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="kw">def</span> map[B](f: A =&gt; B): AnonymousTrait[B] =</a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">new</span> AnonymousTrait[B] {</a>
<a class="sourceLine" id="cb6-14" title="14">      <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>): B =</a>
<a class="sourceLine" id="cb6-15" title="15">        <span class="fu">f</span>(self.<span class="fu">run</span>(rng))</a>
<a class="sourceLine" id="cb6-16" title="16">    }</a>
<a class="sourceLine" id="cb6-17" title="17">}</a>
<a class="sourceLine" id="cb6-18" title="18"><span class="kw">object</span> AnonymousTrait {</a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="kw">def</span> always[A](a: A): AnonymousTrait[A] =</a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="kw">new</span> AnonymousTrait[A] {</a>
<a class="sourceLine" id="cb6-21" title="21">      <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>): A =</a>
<a class="sourceLine" id="cb6-22" title="22">        a</a>
<a class="sourceLine" id="cb6-23" title="23">    }</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25">  <span class="kw">def</span> <span class="dt">int</span>: AnonymousTrait[Int] =</a>
<a class="sourceLine" id="cb6-26" title="26">    <span class="kw">new</span> AnonymousTrait[Int] {</a>
<a class="sourceLine" id="cb6-27" title="27">      <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>): Int =</a>
<a class="sourceLine" id="cb6-28" title="28">        rng.<span class="fu">nextInt</span>()</a>
<a class="sourceLine" id="cb6-29" title="29">    }</a>
<a class="sourceLine" id="cb6-30" title="30"></a>
<a class="sourceLine" id="cb6-31" title="31">  <span class="kw">def</span> <span class="dt">double</span>: AnonymousTrait[Double] =</a>
<a class="sourceLine" id="cb6-32" title="32">    <span class="kw">new</span> AnonymousTrait[Double] {</a>
<a class="sourceLine" id="cb6-33" title="33">      <span class="kw">def</span> <span class="fu">run</span>(rng: scala.<span class="fu">util</span>.<span class="fu">Random</span>): Double =</a>
<a class="sourceLine" id="cb6-34" title="34">        rng.<span class="fu">nextDouble</span>()</a>
<a class="sourceLine" id="cb6-35" title="35">    }</a>
<a class="sourceLine" id="cb6-36" title="36"></a>
<a class="sourceLine" id="cb6-37" title="37">  <span class="kw">implicit</span> <span class="kw">object</span> randomInstance <span class="kw">extends</span> Monad[AnonymousTrait] {</a>
<a class="sourceLine" id="cb6-38" title="38">    <span class="kw">def</span> flatMap[A, B](fa: AnonymousTrait[A])(f: (A) ⇒ AnonymousTrait[B]): AnonymousTrait[B] =</a>
<a class="sourceLine" id="cb6-39" title="39">      fa.<span class="fu">flatMap</span>(f)</a>
<a class="sourceLine" id="cb6-40" title="40"></a>
<a class="sourceLine" id="cb6-41" title="41">    <span class="kw">def</span> pure[A](x: A): AnonymousTrait[A] =</a>
<a class="sourceLine" id="cb6-42" title="42">      AnonymousTrait.<span class="fu">always</span>(x)</a>
<a class="sourceLine" id="cb6-43" title="43">  }</a>
<a class="sourceLine" id="cb6-44" title="44">}</a></code></pre></div>
<p>I’ve also seen this technique used with an unsealed trait. I think this is bad practice. An unsealed trait allows random changes to the semantics by overriding, and doesn’t indicate to the user how they should use the class. Unsealed traits should generally be used for type classes, in my opinion.</p>
<h2 id="modular-interpreters">Modular Interpreters</h2>
<p>One way we can take advantage of the modularity offered by transparent interpreters is by capturing common patterns in reusable classes. This is exactly what the free monad does. Here’s an example of the <code>Random</code> monad using the free monad implementation in Cats. As you can see, we don’t have to write a great deal of code, and we benefit from an optimised and stack-safe implementation.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">object</span> RandomM {</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="kw">import</span> cats.<span class="fu">free</span>.<span class="fu">Free</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">import</span> cats.{Comonad,Monad}</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="kw">type</span> Random[A] = Free[Primitive,A]</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Primitive[A](sample: scala.<span class="fu">util</span>.<span class="fu">Random</span> =&gt; A)</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="kw">implicit</span> <span class="kw">val</span> randomMonad: Monad[Random] = Free.<span class="fu">freeMonad</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="kw">implicit</span> <span class="kw">def</span> <span class="fu">randomInterpreter</span>(<span class="kw">implicit</span> rng: scala.<span class="fu">util</span>.<span class="fu">Random</span> = scala.<span class="fu">util</span>.<span class="fu">Random</span>): Comonad[Primitive] =</a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="kw">new</span> Comonad[Primitive] {</a>
<a class="sourceLine" id="cb7-12" title="12">      <span class="kw">override</span> <span class="kw">def</span> coflatMap[A, B](fa: Primitive[A])(f: (Primitive[A]) ⇒ B): Primitive[B] =</a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="fu">Primitive</span>(rng =&gt; <span class="fu">f</span>(fa))</a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15">      <span class="kw">override</span> <span class="kw">def</span> extract[A](x: Primitive[A]): A =</a>
<a class="sourceLine" id="cb7-16" title="16">        x.<span class="fu">sample</span>(rng)</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">      <span class="kw">override</span> <span class="kw">def</span> map[A, B](fa: Primitive[A])(f: (A) ⇒ B): Primitive[B] =</a>
<a class="sourceLine" id="cb7-19" title="19">        <span class="fu">Primitive</span>(rng =&gt; <span class="fu">f</span>(fa.<span class="fu">sample</span>(rng)))</a>
<a class="sourceLine" id="cb7-20" title="20">    }</a>
<a class="sourceLine" id="cb7-21" title="21">}</a></code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>The transparency tradeoff is a major design decision in creating an interpreter. Over time I feel that as a community we’re moving towards more transparent representations, particularly as techniques like the free monad become more widely known.</p>
<p>Note that transparency is not a binary choice. Even in the transparent implementation above, we have opaque functions passed to <code>flatMap</code> and friends. The ultimate endpoint of a transparent implementation is implementing all language features—conditionals, binding constructs, and everything else—within the little language we’re defining.</p>
<p>The opaque interpreter reminds of <a href="https://en.wikipedia.org/wiki/Higher-order_abstract_syntax">higher order abstract syntax</a> (HOAS), which a technique for representing variable binding in an interpreter by reusing the host language’s implementation. HOAS has the same drawback as our opaque interpreters: since we can’t inspect the structure of the bindings in HOAS we have to use the host language’s semantics. There is <a href="http://repository.upenn.edu/cgi/viewcontent.cgi?article=1031&amp;context=cis_reports">some work</a> on removing this restriction. I’m not familiar enough with this work to say if and how it applies to the discussion here.</p>
<p>Finally, it feels like there is a connection to initial and final encoding, but again I’m not familiar enough to make the connection explicit. Comments are of course open!</p>
    </section>
</article>

                    </main>
                </div>
            </div>
        </div>

        <footer class="text-center">
            <small>
                Site generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </small>
        </footer>
    </body>
</html>
